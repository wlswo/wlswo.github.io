---
layout: minimal_post
title: "JVM 추상적인 내용 구체화"
date: 2026-01-22 10:32:00 +0900
---

> 추상적으로 다가왔던 내용을 구체화하여 정리한다. 

# JVM 클래스 로더가 "읽는다"는 것의 의미

내 컴퓨터에 저장되어 있는 바이트코드로 된 .class 파일을 읽는다. 컴퓨터 입장에서 .class 파일은 하드디스크에 "010100..."과 같은 0과 1로 이루어진 바이너리 코드로 저장되어 있다.

클래스 로더는 이 바이너리 코드 데이터를 스트림으로 읽어 메서드 영역에 <u>C++ 구조체 형태로 저장한다.</u> 메서드 영역에 저장된 정보를 바탕으로, 힙 영역에 java.lang.Class 타입의 객체를 생성한다.

이 객체에는 메서드 영역의 실제 메타데이터를 가리키는 포인터가 주입되어 있어, getName(), getMethods() 같은 메서드를 호출하면 포인터를 타고 메서드 영역으로 넘어가서 정보를 읽어 반환한다.

최초 로딩 시에는 동기화(Synchronization) 블록을 통해 동시에 여러 스레드가 요청해도 딱 한 번만 로딩하고 객체를 생성하도록 제어한다. 따라서 User.class를 코드상에서 100번 호출해도, 힙 영역에 있는 동일한 주소의 java.lang.Class 객체 하나만을 계속해서 반환하게 된다.

```java
class User {
    private String name;
    public int age;
}

public class Main {

  public static void main(String[] args) {

    // 1. Class 객체 획득 (힙 영역의 객체 참조)
    Class<User> user = User.class;

    // 2. 클래스 이름 조회
    System.out.println("Class Name: " + user.getName());

    // 3. 필드 정보 조회 (메서드 영역의 필드 참조)
    System.out.println("\n[Fields]");
    Field[] fields = user.getDeclaredFields();
    System.out.println(java.util.Arrays.toString(fields));

    // 4. 메서드 정보 조회 (메서드 영역의 메서드 참조)
    System.out.println("\n[Methods]");
    Method[] methods = user.getDeclaredMethods();
    System.out.println(java.util.Arrays.toString(methods));
  }
}
```

```text
Class Name: User

[Fields]
[private int User.age, private java.lang.String User.name]

[Methods]
[public void User.printInfo()]

Process finished with exit code 0
```

