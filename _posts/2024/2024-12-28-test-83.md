---
layout: minimal_post
title: "React 성능 최적화: 렌더링 패턴과 메모이제이션"
date: 2024-12-28 12:00:00 +0900
categories: [Tech, Frontend]
tags: [React, JavaScript, Optimization]
---

# React 성능 최적화 가이드

현대 웹 애플리케이션에서 **퍼포먼스(Performance)**는 사용자 경험(UX)과 직결되는 가장 중요한 요소 중 하나입니다. 이 글에서는 React의 렌더링 동작 원리를 이해하고, `useMemo`, `useCallback` 등을 활용한 최적화 전략을 다룹니다.

## 1. 리액트 렌더링의 이해

React는 상태(State)나 속성(Props)이 변경될 때마다 컴포넌트를 다시 렌더링합니다. 이것은 *Virtual DOM*을 사용하여 효율적으로 처리되지만, 불필요한 렌더링이 쌓이면 메인 스레드를 차단할 수 있습니다.

> "최적화는 공짜가 아닙니다. 모든 최적화 코드는 비용이 듭니다. 따라서 **측정(Measure)**하고 **최적화(Optimize)**하세요."

### 렌더링이 발생하는 경우
1. State가 변경되었을 때
2. 부모 컴포넌트가 렌더링될 때
3. Props가 변경되었을 때

---

## 2. 메모이제이션(Memoization) 활용

`useMemo`와 `useCallback`은 비용이 많이 드는 계산 결과나 함수 참조를 저장하여 불필요한 재계산을 방지합니다.

### 무거운 계산 최적화 (`useMemo`)

```javascript
import React, { useMemo, useState } from 'react';

function ComplexCalculation({ list }) {
  const [filter, setFilter] = useState('');

  // list가 변경될 때만 정렬을 수행함 (필터 변경 시에는 수행 안 함)
  const sortedList = useMemo(() => {
    console.log('리스트 정렬 중...');
    return list.sort((a, b) => a.value - b.value);
  }, [list]);

  return (
    <div>
      {/* 렌더링 로직 */}
    </div>
  );
}
```

### 함수 참조 유지 (`useCallback`)

하위 컴포넌트에 props로 함수를 전달할 때 유용합니다.

```typescript
const handleClick = useCallback(() => {
  console.log('Button clicked:', count);
}, [count]); // count가 변하지 않으면 기존 함수 참조를 재사용
```

---

## 3. 리스트 렌더링과 Key

리스트를 렌더링할 때 `key` prop은 React가 DOM 요소를 식별하는 데 필수적입니다.

*   **잘못된 예**: 인덱스(index)를 key로 사용
*   **좋은 예**: 고유한 ID를 key로 사용

| 구분 | 인덱스(Index) 사용 | 고유 ID 사용 |
| :--- | :---: | :---: |
| **데이터 순서 변경** | 비효율적 (전체 리렌더링 위험) | 효율적 (이동된 항목만 처리) |
| **항목 삭제/추가** | 버그 발생 가능성 있음 | 안전함 |
| **안정성** | 낮음 | 높음 |

## 4. 코드 스플리팅 (Code Splitting)

초기 로딩 속도를 줄이기 위해 `React.lazy`와 `Suspense`를 사용하여 코드를 분할할 수 있습니다.

```javascript
// Before
import OtherComponent from './OtherComponent';

// After
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <OtherComponent />
    </React.Suspense>
  );
}
```

### 정리하며

최적화는 다음 순서로 진행하는 것이 좋습니다:
1.  **프로파일링**: React DevTools Profiler 사용
2.  **병목 식별**: 렌더링이 오래 걸리는 컴포넌트 찾기
3.  **적절한 도구 사용**: `React.memo`, `useMemo`, `Virtualization` 등 적용

더 자세한 내용은 [React 공식 문서](https://react.dev)를 참고하세요.

> **Note**: 과도한 최적화(Premature Optimization)는 가독성을 해칠 수 있습니다. 필요한 곳에만 적용하세요.